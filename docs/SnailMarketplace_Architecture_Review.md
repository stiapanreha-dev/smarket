# Отчёт по архитектурному ревью SnailMarketplace
Дата: 2025-11-08

(Содержимое отчёта совпадает с ответом в чате. Этот файл создан для удобства хранения и шаринга.)


# Архитектурное ревью проектируемого маркетплейса

Дата: 2025‑11‑08

Исходные материалы: `marketplace_architecture.md`, `marketplace_diagrams.html` (mermaid‑диаграммы: общая схема, БД/шардинг, CI/CD, Blue‑Green/Canary, последовательность оформления заказа и Saga-компенсации).

---

## TL;DR

Архитектура продуманная и современная: доменное разбиение на микросервисы, асинхронные очереди, кэширование, K8s, строгий DevSecOps и наблюдаемость. Для целевого набора сценариев (товары, курсы, бронирования) выбранный подход жизнеспособен, но есть риски **избыточной сложности для текущего размера команды** и **несоответствия некоторых решений бизнес‑модели маркетплейса** (split‑платежи, выплаты продавцам/мастерам, возвраты). Рекомендую **упростить старт** (ограничить количество сервисов/интеграций), **усилить модель заказов и платежей** под несколько типов товаров/услуг и явным образом описать **консистентность и блокировки** (инвентарь, слоты бронирований).

---

## Что уже хорошо

- Чёткое доменное разбиение: User/Product/Course/Booking/Order/Payment/Notification/Analytics.
- Выделенный **API Gateway** и **Service Mesh (Istio)**; есть rate limiting, маршрутизация, mTLS (по mesh), канареечные релизы и Blue‑Green.
- Асинхронная интеграция через **SQS/RabbitMQ**, DLQ и компенсации (Saga) на диаграммах — хороший фундамент отказоустойчивости.
- Многоуровневое кэширование (**in‑memory/Redis/CDN**), DataLoader для GraphQL — базовая профилактика N+1.
- **Kubernetes + IaC + CI/CD** (сканирование, стейджинг, автодеплой), мониторинг/алертинг (Prometheus/Grafana/логирование) — зрелый DevOps.
- БД разделены по доменам (PostgreSQL/MongoDB/ClickHouse), предусмотрены реплики и PITR‑бэкапы.
- Базовый набор практик безопасности: JWT с ротацией refresh, RBAC, TLS 1.3, WAF/DDoS, аудит логов.

---

## Ключевые замечания и риски

1) **Модель маркетплейса и платежи**  
   - Нужны split‑платежи и **выплаты продавцам/мастерам** (escrow/hold, отложенное списание, комиссии, chargeback/рефанды, частичные возвраты).  
   - Учтите **региональные требования** (KYC/KYB поставщиков, налоговая отчётность, фискализация/чеки, SCA/3DS2).  
   - В Payment Service добавьте: *идемпотентность ключей, надёжную обработку webhooks, повторную доставку, журнал расчётов по мерчантам, reconciliation*.  

2) **Единая модель заказа для трёх доменов** (товары/курсы/бронирования)  
   - Сейчас "Order" описан общо. Рекомендую **line‑item‑ориентированную FSM**: каждый item имеет свой жизненный цикл (товар — резерв/отгрузка, курс — мгновенный доступ, услуга — подтверждение слота/оказание).  
   - Разделите *authorize* и *capture* по типу позиции; поддержите частичные подтверждения/возвраты и многостадийную доставку.  

3) **Консистентность, блокировки и гонки**  
   - **Инвентарь**: резерв при оформлении (ttl‑резервы), анти‑дубль по `idempotency_key`, защита от oversell.  
   - **Бронирования**: конфликтные записи по слоту/мастеру; для горячих слотов — **пессимистические блокировки** или atomic check‑and‑set в Redis + подтверждение в БД.  
   - Оформите **чёткую стратегию транзакций**: где используем локальные транзакции + Saga, где допускаем eventual consistency и как это отражается в UX.  

4) **Каталог и поиск**  
   - Для товаров/услуг/курсов различаются атрибуты и фильтры. В Product/Course/Booking Catalog продумайте **типизированные схемы атрибутов** и **денормализованный поисковый индекс** (OpenSearch/Elasticsearch).  
   - Обновления каталога → **event‑driven реиндексация**; учтите near‑real‑time SLA и отказоустойчивость индекса.  

5) **Выбор СУБД и стоимость**  
   - MongoDB для каталога — ок для гибкой схемы, но можно рассмотреть **PostgreSQL JSONB** + GIN как более дешёвый и унифицированный вариант на старте.  
   - **DocumentDB** в оценке затрат дорог; либо управляемый Mongo Atlas, либо Postgres JSONB. Для ClickHouse уточните объёмы/карточку стоимости и процедуру бэкапов.  

6) **GraphQL Federation + REST**  
   - Два интерфейса одновременно повышают поверхность отказов и задержки. Начните с **BFF‑слоя** и минимальной Federation; включайте федерацию по мере роста команд/границ.  
   - Для GraphQL обязательно: *persisted queries, полиси кэширования, лимиты глубины/сложности, защита от N+1*.  

7) **Service Mesh + API Gateway**  
   - Комбинация Kong + Istio полезна, но **двойная конфигурация** усложняет эксплуатацию. Чётко разграничьте: *edge‑политики* (Gateway) vs *east‑west безопасность и маршрутизация* (Mesh).  

8) **Наблюдаемость и SLO**  
   - Определите SLI/SLO по критическим сценариям: *поиск → корзина → оплата*, *запись на услугу*, *покупка курса*.  
   - Включите **tracing с семплированием** (tail‑based для инцидентов), **error budgets** для принятия релизных решений и **автоматический canary‑анализ**.  

9) **Безопасность и комплаенс**  
   - Secrets: **AWS Secrets Manager/Vault**, ротация ключей JWT/подписей webhooks.  
   - Refresh‑token rotation c детекцией reuse, device‑binding 2FA, контроль сессий.  
   - PII‑карта данных: классификация полей, минимизация, сроки хранения, **право на удаление**.  
   - Неизменяемый **аудит‑лог** (WORM‑хранилище/S3 Object Lock), мониторинг подозрительных действий мерчантов.  

10) **DevOps/эксплуатация**  
   - HPA/VPA, **PodDisruptionBudget**, anti‑affinity, multi‑AZ, резервные каналы очередей, ручки деградации (feature flags).  
   - Политики ресурсов и очередей: приоритетные классы для Checkout/Payment.  
   - **Тесты на нагрузку и хаос** (падение БД, задержки сети, stop‑the‑world GC).

---

## Рекомендации с приоритетом (Impact × Effort)

**Now (0–4 недели)**  
1. Зафиксировать **флоу split‑платежей и выплат** мерчантам/мастерам; уточнить юридические требования в целевых странах/регионах.  
2. Спроектировать **универсальную модель Order/LineItem** с раздельными FSM и компенсациями; описать *authorize/capture/refund/void*.  
3. В Booking и Inventory реализовать **атомарные резервы** (Redis + БД) и идемпотентность; ввести `X-Idempotency-Key`.  
4. В GraphQL включить **persisted queries**, лимиты глубины/сложности, обязательный DataLoader на горячих резолверах.  
5. Упростить периметр: выбрать **одну** очередь (SQS *или* RabbitMQ) на старте, минимизировать Federation.  

**Next (1–3 месяца)**  
6. Выделить **BFF** для Web/Mobile, стандартизовать DTO/валидацию.  
7. В Payment Service — **журнал расчётов и reconciliation**, надёжная обработка webhooks (ретраи, подписи, дедупликация).  
8. Поиск: завести **отдельный индекс** с денормализованными документами; построить пайплайн реиндексации по событиям.  
9. Наблюдаемость: ввести **SLO/SLI**, алертинг по целевым бизнес‑метрикам (успешные оплаты, длительность checkout).  
10. DevOps: PDB/anti‑affinity/multi‑AZ, политики ресурсов, **canary‑анализ** (автороллбэк по метрикам).

**Later (3–6 месяцев)**  
11. Рекомендательная система поверх ClickHouse (или внешний провайдер) после накопления данных.  
12. Расширение федерации GraphQL и разбиение сервисов по независимым командам.  
13. Доработка антифрода (velocity‑лимиты, поведенческие сигналы, device fingerprint).

---

## Замечания по сервисам

- **User Service (PostgreSQL)**  
  Пароли — Argon2id; device‑management; email/phone‑верификация; passwordless опционально; RBAC для продавцов/мастеров/админов; админские действия — в отдельный аудит.  

- **Product/Course/Booking Catalog**  
  Типизированные атрибуты, варианты/опции, версии описаний; превью/медиа через CDN; в курсах — HLS/DASH, водяные знаки, защита ссылок, прогресс+сертификаты.  

- **Inventory Service**  
  Резервы с TTL, дедупликация по ключу операции, фоновые джобы по истечению резерва, защита от double spend.  

- **Booking Service (PostgreSQL + Redis)**  
  Модель расписаний (повторяемость, исключения, часовые пояса), SLAs по отмене/переносу, напоминания, ICS, опция синка с внешними календарями; блокировки слотов атомарными операциями.  

- **Order Service**  
  FSM per line item, частичные доставки/возвраты, статусные вебхуки, аналитика задержек, SLA на этапы.  

- **Payment Service**  
  Поддержка нескольких PSP; split‑платежи/escrow, idempotency keys, защита webhooks (подпись/ротация), хранение токенов у PSP, отчётность и сведение.  

- **Notification Service**  
  Хранилище шаблонов (версии/локали), переменные с валидацией, fallback‑каналы, наблюдаемость доставляемости (open/click/drop).  

- **Analytics Service (ClickHouse)**  
  Схема событий, деперсонализация, согласия (consent), экспорт в BI; бэкапы/TTL‑политики таблиц.  

---

## Открытые вопросы (стоит зафиксировать)

1. Целевые рынки/юрисдикции → требования по платежам/фискализации/налогам/GDPR.  
2. Модель маркетплейса: кто держатель средств, сроки удержаний, комиссии, расписание выплат, арбитраж споров.  
3. SLAs по типам заказов (товары/услуги/курсы), допустимая eventual consistency, UX при задержках.  
4. План миграции от упрощённой архитектуры (BFF + несколько сервисов) к полной федерации/mesh.  
5. Трафик/нагрузка MVP: прогноз по RPS/карточке товара/поиску/чекауту, пиковые события (распродажи).

---

## Чек‑лист готовности к MVP

- [ ] Persisted GraphQL queries, лимиты глубины/сложности, DataLoader.  
- [ ] Idempotency в Checkout/Payment, резервы инвентаря и слотов.  
- [ ] Каноническая модель Order/LineItem + FSM + компенсирующие транзакции.  
- [ ] One‑queue‑policy (SQS **или** RabbitMQ) + DLQ и ретраи.  
- [ ] SLI/SLO по воронке покупки; алерты на падение успешных оплат.  
- [ ] Secrets/keys под управлением (Vault/ASM), ротация и аудит.  
- [ ] PDB/anti‑affinity/multi‑AZ, бэкапы и проверка восстановления.  
- [ ] Процедуры отката (Blue‑Green/Canary с автоанализом) и учебные тревоги.

---

## Итог

Архитектура отвечает целям масштабируемости и модульности. Наибольший выигрыш в ближайшее время даст **упрощение стартовой конфигурации**, **пересмотр модели заказов и платежей под специфику маркетплейса** и **жёсткая дисциплина консистентности** для инвентаря и бронирований. Это сократит Time‑to‑Market без потери эволюционности и позволит безопасно масштабироваться по мере роста бизнеса.
